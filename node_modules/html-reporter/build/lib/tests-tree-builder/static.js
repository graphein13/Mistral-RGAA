"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticTestsTreeBuilder = void 0;
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const constants_1 = require("../constants");
const sqlite_1 = require("../adapters/test-result/sqlite");
class StaticTestsTreeBuilder extends base_1.BaseTestsTreeBuilder {
    constructor(options) {
        super(options);
        this._stats = {
            ...initStats(),
            perBrowser: {}
        };
        this._skips = [];
        this._failedTestIds = {};
        this._passedTestIds = {};
        this._skippedTestIds = {};
    }
    build(rows = []) {
        const attemptsMap = new Map();
        const browsers = {};
        for (const row of rows) {
            const testPath = JSON.parse(row[constants_1.DB_COLUMN_INDEXES.suitePath]);
            const browserName = row[constants_1.DB_COLUMN_INDEXES.name];
            const testId = this._buildId(testPath);
            const browserId = this._buildId(testId, browserName);
            attemptsMap.set(browserId, attemptsMap.has(browserId) ? attemptsMap.get(browserId) + 1 : 0);
            const attempt = attemptsMap.get(browserId);
            const formattedResult = new sqlite_1.SqliteTestResultAdapter(row, attempt);
            addBrowserVersion(browsers, formattedResult);
            this.addTestResult(formattedResult);
            this._calcStats(formattedResult, { testId, browserName });
        }
        this.sortTree();
        return {
            tree: this.tree,
            stats: this._stats,
            skips: this._skips,
            browsers: lodash_1.default.map(browsers, (versions, id) => ({ id, versions: Array.from(versions) }))
        };
    }
    _addResultIdToBrowser(browserId, testResultId) {
        this._tree.browsers.byId[browserId].resultIds.push(testResultId);
    }
    _calcStats(testResult, { testId, browserName }) {
        const testIdWithBrowser = this._buildId(testId, browserName);
        const { status } = testResult;
        const { browserVersion } = testResult.meta;
        const version = browserVersion || constants_1.BrowserVersions.UNKNOWN;
        if (!this._stats.perBrowser[browserName]) {
            this._stats.perBrowser[browserName] = {};
        }
        if (!this._stats.perBrowser[browserName][version]) {
            this._stats.perBrowser[browserName][version] = initStats();
        }
        switch (status) {
            case constants_1.TestStatus.FAIL:
            case constants_1.TestStatus.ERROR: {
                if (this._failedTestIds[testIdWithBrowser]) {
                    this._stats.retries++;
                    this._stats.perBrowser[browserName][version].retries++;
                    return;
                }
                this._failedTestIds[testIdWithBrowser] = true;
                this._stats.failed++;
                this._stats.total++;
                this._stats.perBrowser[browserName][version].failed++;
                this._stats.perBrowser[browserName][version].total++;
                return;
            }
            case constants_1.TestStatus.SUCCESS: {
                if (this._passedTestIds[testIdWithBrowser]) {
                    this._stats.retries++;
                    this._stats.perBrowser[browserName][version].retries++;
                    return;
                }
                if (this._failedTestIds[testIdWithBrowser]) {
                    delete this._failedTestIds[testIdWithBrowser];
                    this._stats.failed--;
                    this._stats.passed++;
                    this._stats.retries++;
                    this._stats.perBrowser[browserName][version].failed--;
                    this._stats.perBrowser[browserName][version].passed++;
                    this._stats.perBrowser[browserName][version].retries++;
                    return;
                }
                this._passedTestIds[testIdWithBrowser] = true;
                this._stats.passed++;
                this._stats.total++;
                this._stats.perBrowser[browserName][version].passed++;
                this._stats.perBrowser[browserName][version].total++;
                return;
            }
            case constants_1.TestStatus.SKIPPED: {
                if (this._skippedTestIds[testIdWithBrowser]) {
                    this._stats.retries++;
                    this._stats.perBrowser[browserName][version].retries++;
                    return;
                }
                this._skippedTestIds[testIdWithBrowser] = true;
                this._skips.push({
                    browser: browserName,
                    suite: testId,
                    comment: testResult.skipReason
                });
                this._stats.skipped++;
                this._stats.perBrowser[browserName][version].skipped++;
                if (this._failedTestIds[testIdWithBrowser]) {
                    delete this._failedTestIds[testIdWithBrowser];
                    this._stats.failed--;
                    this._stats.perBrowser[browserName][version].failed--;
                    return;
                }
                this._stats.total++;
                this._stats.perBrowser[browserName][version].total++;
            }
        }
    }
}
exports.StaticTestsTreeBuilder = StaticTestsTreeBuilder;
function initStats() {
    return {
        total: 0,
        passed: 0,
        failed: 0,
        skipped: 0,
        retries: 0
    };
}
function addBrowserVersion(browsers, testResult) {
    const { browserId } = testResult;
    if (!browsers[browserId]) {
        browsers[browserId] = new Set();
    }
    const { browserVersion = constants_1.BrowserVersions.UNKNOWN } = testResult.meta;
    browsers[browserId].add(browserVersion);
}
//# sourceMappingURL=static.js.map