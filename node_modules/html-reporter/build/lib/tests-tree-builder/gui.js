"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuiTestsTreeBuilder = void 0;
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const constants_1 = require("../constants");
const common_utils_1 = require("../common-utils");
class GuiTestsTreeBuilder extends base_1.BaseTestsTreeBuilder {
    getImagesInfo(testId) {
        return this._tree.results.byId[testId].imageIds.map((imageId) => {
            return this._tree.images.byId[imageId];
        });
    }
    getTestBranch(id) {
        const getSuites = (suite) => {
            if (suite.root) {
                return [{ id: suite.id, status: suite.status }];
            }
            return lodash_1.default.flatten([
                getSuites(this._tree.suites.byId[suite.parentId]),
                { id: suite.id, status: suite.status }
            ]);
        };
        const result = this._tree.results.byId[id];
        const images = result.imageIds.map((imgId) => this._tree.images.byId[imgId]);
        const browser = this._tree.browsers.byId[result.parentId];
        const suites = getSuites(this._tree.suites.byId[browser.parentId]);
        return { result, images, suites };
    }
    getTestsDataToUpdateRefs(imageIds) {
        const imagesById = [].concat(imageIds).reduce((acc, imgId) => {
            acc[imgId] = this._tree.images.byId[imgId];
            return acc;
        }, {});
        const imagesByResultId = lodash_1.default.groupBy(imagesById, 'parentId');
        return Object.keys(imagesByResultId).map((resultId) => {
            const result = this._tree.results.byId[resultId];
            const browser = this._tree.browsers.byId[result.parentId];
            const suite = this._tree.suites.byId[browser.parentId];
            const imagesInfo = imagesByResultId[resultId]
                .filter(treeImage => treeImage.stateName)
                .map((treeImage) => ({
                stateName: treeImage.stateName,
                actualImg: treeImage.actualImg,
                status: constants_1.UPDATED
            }));
            return {
                suite: { path: suite.suitePath.slice(0, -1) },
                state: { name: suite.name },
                browserId: browser.name,
                error: result.error,
                metaInfo: result.metaInfo,
                imagesInfo,
                attempt: result.attempt
            };
        });
    }
    getImageDataToFindEqualDiffs(imageIds) {
        return imageIds.map((imageId) => {
            const image = this._tree.images.byId[imageId];
            const result = this._tree.results.byId[image.parentId];
            const { name: browserName } = this._tree.browsers.byId[result.parentId];
            return { ...image, browserName };
        });
    }
    getResultDataToUnacceptImage(resultId, stateName) {
        const imageId = this._tree.results.byId[resultId].imageIds.find(imageId => {
            return this._tree.images.byId[imageId].stateName === stateName;
        });
        if (!imageId) {
            return null;
        }
        const image = this._tree.images.byId[imageId];
        const result = this._tree.results.byId[image.parentId];
        const browser = this._tree.browsers.byId[result.parentId];
        const previousResultId = browser.resultIds.find((_, ind, resultIds) => resultIds[ind + 1] === result.id);
        const previousResult = previousResultId ? this._tree.results.byId[previousResultId] : null;
        const previousImageId = previousResult
            ? previousResult.imageIds.find(imageId => this._tree.images.byId[imageId].stateName ===
                image.stateName)
            : null;
        const previousImage = previousImageId
            ? this._tree.images.byId[previousImageId]
            : null;
        const countUpdated = result.imageIds.reduce((acc, currImageId) => {
            return (0, common_utils_1.isUpdatedStatus)(this._tree.images.byId[currImageId].status) ? acc + 1 : acc;
        }, 0);
        const shouldRemoveResult = (0, common_utils_1.isUpdatedStatus)(image.status) && countUpdated === 1;
        return {
            imageId,
            status: image.status,
            timestamp: result.timestamp,
            previousImage,
            previousImageId,
            shouldRemoveResult
        };
    }
    reuseTestsTree(testsTree) {
        this._tree.browsers.allIds.forEach((browserId) => this._reuseBrowser(testsTree, browserId));
    }
    updateImageInfo(imageId, imageInfo) {
        const currentImage = this._tree.images.byId[imageId];
        // TODO: check TreeImage type. Is it correct to let it consist of id and parentId?
        const updatedImage = {
            ...imageInfo,
            id: currentImage.id,
            parentId: currentImage.parentId
        };
        this._tree.images.byId[imageId] = updatedImage;
        return updatedImage;
    }
    removeTestResult(resultId) {
        const result = this._tree.results.byId[resultId];
        this._removeImagesById(result.imageIds);
        this._tree.browsers.byId[result.parentId].resultIds =
            this._tree.browsers.byId[result.parentId].resultIds.filter(id => id !== resultId);
        this._tree.results.allIds = this._tree.results.allIds.filter(id => id !== resultId);
        delete this._tree.results.byId[resultId];
    }
    _removeImagesById(imageIds) {
        this._tree.images.allIds = this._tree.images.allIds.filter(id => !imageIds.includes(id));
        imageIds.forEach(imageId => {
            delete this._tree.images.byId[imageId];
        });
    }
    _reuseBrowser(testsTree, browserId) {
        const reuseBrowser = testsTree.browsers.byId[browserId];
        if (!reuseBrowser) {
            return;
        }
        this._tree.browsers.byId[browserId] = reuseBrowser;
        reuseBrowser.resultIds.forEach((resultId) => this._reuseResults(testsTree, resultId));
        this._reuseSuiteStatus(testsTree, this._tree.browsers.byId[browserId].parentId);
    }
    _reuseResults(testsTree, resultId) {
        const reuseResult = testsTree.results.byId[resultId];
        if (!this._tree.results.byId[resultId]) {
            this._tree.results.allIds.push(resultId);
        }
        this._tree.results.byId[resultId] = reuseResult;
        reuseResult.imageIds.forEach((imageId) => this._reuseImages(testsTree, imageId));
    }
    _reuseImages(testsTree, imageId) {
        const reuseImage = testsTree.images.byId[imageId];
        if (!this._tree.images.byId[imageId]) {
            this._tree.images.allIds.push(imageId);
        }
        this._tree.images.byId[imageId] = reuseImage;
    }
    _reuseSuiteStatus(testsTree, suiteId) {
        if (!suiteId) {
            return;
        }
        const suite = this._tree.suites.byId[suiteId];
        suite.status = testsTree.suites.byId[suiteId].status;
        this._reuseSuiteStatus(testsTree, suite.parentId);
    }
}
exports.GuiTestsTreeBuilder = GuiTestsTreeBuilder;
//# sourceMappingURL=gui.js.map