"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeTables = exports.handleDatabases = exports.compareDatabaseRowsByTimestamp = exports.createTablesQuery = exports.selectAllSuitesQuery = exports.selectAllQuery = void 0;
const lodash_1 = __importDefault(require("lodash"));
const common_utils_1 = require("../common-utils");
const constants_1 = require("../constants");
const selectAllQuery = (tableName) => `SELECT * FROM ${tableName}`;
exports.selectAllQuery = selectAllQuery;
const selectAllSuitesQuery = () => (0, exports.selectAllQuery)(constants_1.DB_SUITES_TABLE_NAME);
exports.selectAllSuitesQuery = selectAllSuitesQuery;
const createTablesQuery = () => [
    createTableQuery(constants_1.DB_SUITES_TABLE_NAME, constants_1.SUITES_TABLE_COLUMNS)
];
exports.createTablesQuery = createTablesQuery;
const compareDatabaseRowsByTimestamp = (row1, row2) => {
    return row1[constants_1.DB_COLUMN_INDEXES.timestamp] - row2[constants_1.DB_COLUMN_INDEXES.timestamp];
};
exports.compareDatabaseRowsByTimestamp = compareDatabaseRowsByTimestamp;
const handleDatabases = async (dbJsonUrls, opts) => {
    return lodash_1.default.flattenDeep(await Promise.all(dbJsonUrls.map(async (dbJsonUrl) => {
        try {
            const currentJsonResponse = await opts.loadDbJsonUrl(dbJsonUrl);
            if (!currentJsonResponse.data) {
                common_utils_1.logger.warn(`Cannot get data from ${dbJsonUrl}`);
                return opts.formatData ? opts.formatData(dbJsonUrl, currentJsonResponse.status) : [];
            }
            const { dbUrls, jsonUrls } = currentJsonResponse.data;
            const preparedDbUrls = opts.prepareUrls(dbUrls, dbJsonUrl);
            const preparedDbJsonUrls = opts.prepareUrls(jsonUrls, dbJsonUrl);
            return await Promise.all([
                (0, exports.handleDatabases)(preparedDbJsonUrls, opts),
                ...preparedDbUrls.map((dbUrl) => opts.loadDbUrl(dbUrl, opts))
            ]);
        }
        catch (e) {
            common_utils_1.logger.warn(`Error while downloading databases from ${dbJsonUrl}`, e);
            return opts.formatData ? opts.formatData(dbJsonUrl) : [];
        }
    })));
};
exports.handleDatabases = handleDatabases;
const mergeTables = ({ db, dbPaths, getExistingTables = () => [] }) => {
    db.prepare(`PRAGMA page_size = ${constants_1.DB_MAX_AVAILABLE_PAGE_SIZE}`).run();
    for (const dbPath of dbPaths) {
        db.prepare(`ATTACH DATABASE '${dbPath}' AS attached`).run();
        const getTablesStatement = db.prepare(`SELECT name FROM attached.sqlite_master WHERE type='table'`);
        const tables = getExistingTables(getTablesStatement);
        for (const tableName of tables) {
            db.prepare(`CREATE TABLE IF NOT EXISTS ${tableName} AS SELECT * FROM attached.${tableName} LIMIT 0`).run();
            db.prepare(`INSERT OR IGNORE INTO ${tableName} SELECT * FROM attached.${tableName}`).run();
        }
        db.prepare(`DETACH attached`).run();
    }
};
exports.mergeTables = mergeTables;
function createTableQuery(tableName, columns) {
    const formattedColumns = columns
        .map(({ name, type }) => `${name} ${type}`)
        .join(', ');
    return `CREATE TABLE IF NOT EXISTS ${tableName} (${formattedColumns})`;
}
//# sourceMappingURL=common.js.map