"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterByEqualDiffSizes = exports.mergeDatabasesForReuse = exports.mkFullTitle = exports.formatId = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const common_utils_1 = require("../../common-utils");
const constants_1 = require("../../constants");
const server_1 = require("../../db-utils/server");
const formatId = (hash, browserId) => `${hash}/${browserId}`;
exports.formatId = formatId;
const mkFullTitle = ({ suite, state }) => {
    return suite.path.length > 0 ? `${suite.path.join(' ')} ${state.name}` : state.name;
};
exports.mkFullTitle = mkFullTitle;
const mergeDatabasesForReuse = async (reportPath) => {
    const dbUrlsJsonPath = path_1.default.resolve(reportPath, constants_1.DATABASE_URLS_JSON_NAME);
    const mergedDbPath = path_1.default.resolve(reportPath, constants_1.LOCAL_DATABASE_NAME);
    if (!await fs_extra_1.default.pathExists(dbUrlsJsonPath)) {
        return;
    }
    const { dbUrls = [] } = await fs_extra_1.default.readJson(dbUrlsJsonPath);
    const dbPaths = dbUrls
        .filter(u => u !== constants_1.LOCAL_DATABASE_NAME)
        .map(u => path_1.default.resolve(reportPath, u));
    if (!dbPaths.length) {
        return;
    }
    common_utils_1.logger.warn(chalk_1.default.yellow(`Merge databases to ${constants_1.LOCAL_DATABASE_NAME}`));
    const mergedDatabase = new better_sqlite3_1.default(mergedDbPath);
    (0, server_1.mergeTables)({
        db: mergedDatabase,
        dbPaths,
        getExistingTables: (statement) => {
            return statement.all().map((table) => table.name);
        }
    });
    mergedDatabase.close();
    await Promise.all(dbPaths.map(p => fs_extra_1.default.remove(p)));
};
exports.mergeDatabasesForReuse = mergeDatabasesForReuse;
const filterByEqualDiffSizes = (imagesInfo, refDiffClusters) => {
    if (!refDiffClusters || lodash_1.default.isEmpty(refDiffClusters)) {
        return [];
    }
    const refDiffSizes = refDiffClusters.map(getDiffClusterSizes);
    return lodash_1.default.filter(imagesInfo, (imageInfo) => {
        const imageInfoFail = imageInfo;
        const imageDiffSizes = imageInfoFail.diffClusters?.map(getDiffClusterSizes) ?? [];
        const equal = compareDiffSizes(imageDiffSizes, refDiffSizes);
        if (!equal) {
            return false;
        }
        if (!lodash_1.default.isEqual(imageDiffSizes, refDiffSizes)) {
            imageInfoFail.diffClusters = reorderClustersByEqualSize(imageInfoFail.diffClusters ?? [], imageDiffSizes, refDiffSizes);
        }
        return true;
    });
};
exports.filterByEqualDiffSizes = filterByEqualDiffSizes;
function getDiffClusterSizes(diffCluster) {
    return {
        width: diffCluster.right - diffCluster.left + 1,
        height: diffCluster.bottom - diffCluster.top + 1
    };
}
function compareDiffSizes(diffSizes1, diffSizes2) {
    if (diffSizes1.length !== diffSizes2.length) {
        return false;
    }
    return diffSizes1.every((diffSize) => {
        const foundIndex = lodash_1.default.findIndex(diffSizes2, diffSize);
        if (foundIndex < 0) {
            return false;
        }
        diffSizes2 = diffSizes2.filter((_v, ind) => ind !== foundIndex);
        return true;
    });
}
function reorderClustersByEqualSize(diffClusters1, diffSizes1, diffSizes2) {
    return diffClusters1.reduce((acc, cluster, i) => {
        if (diffSizes1[i] !== diffSizes2[i]) {
            const foundIndex = lodash_1.default.findIndex(diffSizes2, diffSizes1[i]);
            diffSizes2 = diffSizes2.filter((_v, ind) => ind !== foundIndex);
            acc[foundIndex] = cluster;
        }
        else {
            acc[i] = cluster;
        }
        return acc;
    }, []);
}
//# sourceMappingURL=utils.js.map