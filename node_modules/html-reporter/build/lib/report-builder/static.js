"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticReportBuilder = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const p_queue_1 = __importDefault(require("p-queue"));
const constants_1 = require("../constants");
const server_utils_1 = require("../server-utils");
const server_1 = require("../db-utils/server");
const test_attempt_manager_1 = require("../test-attempt-manager");
const utils_1 = require("../adapters/test-result/utils");
const ignoredStatuses = [constants_1.RUNNING, constants_1.IDLE];
class StaticReportBuilder {
    static create(options) {
        return new this(options);
    }
    constructor({ htmlReporter, reporterConfig, dbClient, imagesInfoSaver }) {
        this._htmlReporter = htmlReporter;
        this._reporterConfig = reporterConfig;
        this._dbClient = dbClient;
        this._testAttemptManager = new test_attempt_manager_1.TestAttemptManager();
        this._imagesInfoSaver = imagesInfoSaver;
        this._htmlReporter.on(constants_1.PluginEvents.IMAGES_SAVER_UPDATED, (newImagesSaver) => {
            this._imagesInfoSaver.setImageFileSaver(newImagesSaver);
        });
        this._htmlReporter.listenTo(this._imagesInfoSaver, [constants_1.PluginEvents.TEST_SCREENSHOTS_SAVED]);
    }
    async saveStaticFiles() {
        const destPath = this._reporterConfig.path;
        await Promise.all([
            (0, server_utils_1.saveStaticFilesToReportDir)(this._htmlReporter, this._reporterConfig, destPath),
            (0, server_utils_1.writeDatabaseUrlsFile)(destPath, [constants_1.LOCAL_DATABASE_NAME])
        ]);
    }
    registerWorkers(workers) {
        this._workers = workers;
    }
    registerAttempt(testInfo, status) {
        return this._testAttemptManager.registerAttempt(testInfo, status);
    }
    getLatestAttempt(testInfo) {
        return this._testAttemptManager.getCurrentAttempt(testInfo);
    }
    /** If passed test result doesn't have attempt, this method registers new attempt and sets attempt number */
    provideAttempt(testResultOriginal) {
        let formattedResult = testResultOriginal;
        if (testResultOriginal.attempt === constants_1.UNKNOWN_ATTEMPT) {
            const attempt = this._testAttemptManager.registerAttempt(testResultOriginal, testResultOriginal.status);
            formattedResult = (0, utils_1.copyAndUpdate)(testResultOriginal, { attempt });
        }
        return formattedResult;
    }
    async _saveTestResultData(testResult) {
        if ([constants_1.IDLE, constants_1.RUNNING, constants_1.UPDATED].includes(testResult.status)) {
            return testResult;
        }
        const actions = new p_queue_1.default();
        let testResultWithImagePaths = testResult;
        actions.add(async () => {
            testResultWithImagePaths = await this._imagesInfoSaver.save(testResult, this._workers);
        });
        if (this._reporterConfig.saveErrorDetails && testResult.errorDetails) {
            actions.add(async () => (0, server_utils_1.saveErrorDetails)(testResult, this._reporterConfig.path));
        }
        await actions.onIdle();
        return testResultWithImagePaths;
    }
    async addTestResult(formattedResultOriginal) {
        const formattedResult = this.provideAttempt(formattedResultOriginal);
        // Test result data has to be saved before writing to db, because user may save data to custom location
        const testResultWithImagePaths = await this._saveTestResultData(formattedResult);
        // To prevent skips duplication on reporter startup
        const isPreviouslySkippedTest = testResultWithImagePaths.status === constants_1.SKIPPED && (0, server_1.getTestFromDb)(this._dbClient, formattedResult);
        if (!ignoredStatuses.includes(testResultWithImagePaths.status) && !isPreviouslySkippedTest) {
            this._dbClient.write(testResultWithImagePaths);
        }
        return testResultWithImagePaths;
    }
    _deleteTestResultFromDb(...args) {
        this._dbClient.delete(...args);
    }
    async finalize() {
        this._dbClient.close();
        const reportsSaver = this._htmlReporter.reportsSaver;
        if (reportsSaver) {
            const reportDir = this._reporterConfig.path;
            const src = path_1.default.join(reportDir, constants_1.LOCAL_DATABASE_NAME);
            const dbPath = await reportsSaver.saveReportData(src, { destPath: constants_1.LOCAL_DATABASE_NAME, reportDir: reportDir });
            await (0, server_utils_1.writeDatabaseUrlsFile)(reportDir, [dbPath]);
            await fs_extra_1.default.remove(src);
        }
    }
}
exports.StaticReportBuilder = StaticReportBuilder;
//# sourceMappingURL=static.js.map