"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestplaneTestResultAdapter = exports.getStatus = void 0;
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const constants_1 = require("../../constants");
const common_utils_1 = require("../../common-utils");
const types_1 = require("../../types");
const plugin_utils_1 = require("../../plugin-utils");
const utils_1 = require("./utils");
const getStatus = (eventName, events, testResult) => {
    if (eventName === events.TEST_PASS) {
        return constants_1.TestStatus.SUCCESS;
    }
    else if (eventName === events.TEST_PENDING) {
        return constants_1.TestStatus.SKIPPED;
    }
    else if (eventName === events.RETRY || eventName === events.TEST_FAIL) {
        return (0, common_utils_1.hasUnrelatedToScreenshotsErrors)(testResult.err) ? constants_1.TestStatus.ERROR : constants_1.TestStatus.FAIL;
    }
    else if (eventName === events.TEST_BEGIN) {
        return constants_1.TestStatus.RUNNING;
    }
    return constants_1.TestStatus.IDLE;
};
exports.getStatus = getStatus;
const getSkipComment = (suite) => {
    return suite.skipReason || suite.parent && getSkipComment(suite.parent);
};
const wrapSkipComment = (skipComment) => {
    return skipComment ?? 'Unknown reason';
};
const getHistory = (history) => {
    return history?.map(h => {
        const result = {
            [types_1.TestStepKey.Name]: h[types_1.TestStepKey.Name],
            [types_1.TestStepKey.Args]: h[types_1.TestStepKey.Args],
            [types_1.TestStepKey.Duration]: h[types_1.TestStepKey.Duration],
            [types_1.TestStepKey.TimeStart]: h[types_1.TestStepKey.TimeStart],
            [types_1.TestStepKey.IsFailed]: h[types_1.TestStepKey.IsFailed],
            [types_1.TestStepKey.IsGroup]: h[types_1.TestStepKey.IsGroup]
        };
        if (h[types_1.TestStepKey.Children] && h[types_1.TestStepKey.IsFailed]) {
            result[types_1.TestStepKey.Children] = getHistory(h[types_1.TestStepKey.Children]);
        }
        return result;
    }) ?? [];
};
class TestplaneTestResultAdapter {
    static create(testResult, options) {
        return new this(testResult, options);
    }
    constructor(testResult, { attempt, status, duration }) {
        this._testResult = testResult;
        this._errorDetails = null;
        this._timestamp = this._testResult.startTime
            ?? this._testResult.timestamp
            ?? Date.now();
        this._status = status;
        const browserVersion = lodash_1.default.get(this._testResult, 'meta.browserVersion', this._testResult.browserVersion);
        lodash_1.default.set(this._testResult, 'meta.browserVersion', browserVersion);
        this._attempt = attempt;
        this._duration = duration;
    }
    get fullName() {
        return this._testResult.fullTitle();
    }
    get skipReason() {
        return wrapSkipComment(getSkipComment(this._testResult));
    }
    get status() {
        return this._status;
    }
    get sessionId() {
        return this._testResult.sessionId || constants_1.UNKNOWN_SESSION_ID;
    }
    get browserId() {
        return this._testResult.browserId;
    }
    get imagesInfo() {
        const { assertViewResults = [] } = this._testResult;
        const imagesInfo = assertViewResults.map((assertResult) => {
            if ((0, common_utils_1.isImageDiffError)(assertResult)) {
                const diffBufferImg = assertResult.diffBuffer ? { buffer: assertResult.diffBuffer } : undefined;
                const diffImg = assertResult.diffImg ?? diffBufferImg;
                return {
                    status: constants_1.FAIL,
                    stateName: assertResult.stateName,
                    refImg: assertResult.refImg,
                    actualImg: assertResult.currImg,
                    ...(diffImg ? { diffImg } : {}),
                    expectedImg: lodash_1.default.clone(assertResult.refImg),
                    diffClusters: assertResult.diffClusters,
                    diffOptions: assertResult.diffOpts,
                    differentPixels: assertResult.differentPixels,
                    diffRatio: assertResult.diffRatio
                };
            }
            else if ((0, common_utils_1.isNoRefImageError)(assertResult)) {
                return {
                    status: constants_1.ERROR,
                    stateName: assertResult.stateName,
                    error: lodash_1.default.pick(assertResult, ['message', 'name', 'stack']),
                    refImg: assertResult.refImg,
                    actualImg: assertResult.currImg
                };
            }
            else if ((0, common_utils_1.isInvalidRefImageError)(assertResult)) {
                return {
                    status: constants_1.ERROR,
                    stateName: assertResult.stateName,
                    error: lodash_1.default.pick(assertResult, ['message', 'name', 'stack']),
                    refImg: assertResult.refImg,
                    actualImg: assertResult.currImg
                };
            }
            else if (assertResult.isUpdated) {
                return {
                    status: constants_1.UPDATED,
                    stateName: assertResult.stateName,
                    refImg: assertResult.refImg,
                    expectedImg: lodash_1.default.clone(assertResult.refImg),
                    actualImg: assertResult.currImg
                };
            }
            else {
                const { currImg } = assertResult;
                return {
                    status: constants_1.SUCCESS,
                    stateName: assertResult.stateName,
                    refImg: assertResult.refImg,
                    expectedImg: lodash_1.default.clone(assertResult.refImg),
                    ...(currImg ? { actualImg: currImg } : {})
                };
            }
        });
        if (this.screenshot) {
            imagesInfo.push({
                status: lodash_1.default.isEmpty((0, common_utils_1.getError)(this.error)) ? constants_1.SUCCESS : constants_1.ERROR,
                actualImg: this.screenshot
            });
        }
        return imagesInfo;
    }
    get attempt() {
        return this._attempt;
    }
    get history() {
        return getHistory(this._testResult.history);
    }
    get error() {
        return this._testResult.err;
    }
    get imageDir() {
        // TODO: remove toString after publish major version
        return this._testResult.id.toString();
    }
    get state() {
        return { name: this._testResult.title };
    }
    get testPath() {
        return (0, plugin_utils_1.getSuitePath)(this._testResult.parent).concat(this._testResult.title);
    }
    get id() {
        return this.testPath.concat(this.browserId, this.attempt.toString()).join(' ');
    }
    get screenshot() {
        return lodash_1.default.get(this._testResult, 'err.screenshot');
    }
    get description() {
        return this._testResult.description;
    }
    get meta() {
        return this._testResult.meta ?? {};
    }
    get errorDetails() {
        if (!lodash_1.default.isNil(this._errorDetails)) {
            return this._errorDetails;
        }
        this._errorDetails = (0, utils_1.extractErrorDetails)(this);
        return this._errorDetails;
    }
    get file() {
        return path_1.default.relative(process.cwd(), this._testResult.file);
    }
    get url() {
        return this._testResult.meta?.url;
    }
    get multipleTabs() {
        return true;
    }
    get timestamp() {
        return this._timestamp;
    }
    set timestamp(timestamp) {
        if (!lodash_1.default.isNumber(this._timestamp)) {
            this._timestamp = timestamp ?? 0;
        }
    }
    get duration() {
        return this._duration;
    }
    get attachments() {
        return [];
    }
}
exports.TestplaneTestResultAdapter = TestplaneTestResultAdapter;
//# sourceMappingURL=testplane.js.map