"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JestTestResultAdapter = void 0;
const constants_1 = require("../../constants");
const errors_1 = require("../../errors");
const path_1 = __importDefault(require("path"));
class JestTestResultAdapter {
    static create(test, testResult, assertionResult, attempt) {
        return new this(test, testResult, assertionResult, attempt);
    }
    constructor(test, testResult, assertionResult, attempt = assertionResult.invocations ?? constants_1.UNKNOWN_ATTEMPT) {
        this._test = test;
        this._testResult = testResult;
        this._assertionResult = assertionResult;
        this._attempt = attempt;
    }
    get attachments() {
        return [];
    }
    get attempt() {
        return this._attempt;
    }
    get browserId() {
        return `Node ${process.version}`;
    }
    get description() {
        return this._test.context.config.displayName?.name
            ?? this._assertionResult.title;
    }
    getErrorMessage() {
        if (this._assertionResult.status !== 'failed') {
            return;
        }
        const details = this._assertionResult.failureDetails[0];
        if (!details || !details?.message) {
            // failureDetails is of type unknown.
            // Usually it is an object with message field, but other possible cases handles here
            return 'The test crashed and we can\'t read the error message.\n'
                + `Please, report an issue at ${constants_1.NEW_ISSUE_LINK}\n`
                + '\n'
                + 'Failure details we can\'t read:\n'
                + JSON.stringify(this._assertionResult.failureDetails);
        }
        return details.message;
    }
    getErrorStack() {
        if (this._assertionResult.status !== 'failed') {
            return;
        }
        return this._assertionResult.failureMessages.join('\n');
    }
    get error() {
        if (this._assertionResult.status !== 'failed') {
            return;
        }
        const message = this.getErrorMessage();
        if (message) {
            const result = { name: errors_1.ErrorName.GENERAL_ERROR, message };
            result.stack = this.getErrorStack();
            return result;
        }
        return undefined;
    }
    get errorDetails() {
        if (this._assertionResult.status !== 'failed') {
            return null;
        }
        const title = this.description;
        const filePath = this.file;
        return {
            title,
            filePath
        };
    }
    get file() {
        return path_1.default.relative(process.cwd(), this._test.path);
    }
    get fullName() {
        return [
            ...this.testPath
        ].join(' ');
    }
    get id() {
        return [
            this.file,
            ...this.testPath,
            this.browserId,
            this.attempt.toString()
        ].join(' ');
    }
    get imageDir() {
        // Not suitable for jest
        return '';
    }
    get imagesInfo() {
        return [];
    }
    get meta() {
        return {
            'tests failed in file': String(this._testResult.numFailingTests),
            'tests passed in file': String(this._testResult.numPassingTests),
            'file duration': this._testResult.perfStats.runtime + ' ms'
        };
    }
    get multipleTabs() {
        return true;
    }
    get screenshot() {
        return null;
    }
    get sessionId() {
        return '';
    }
    get skipReason() {
        return this._testResult.skipped ? 'Skipped' : '';
    }
    get state() {
        return { name: this.description };
    }
    get status() {
        const status = this._assertionResult.status;
        switch (status) {
            case 'failed':
                return constants_1.TestStatus.ERROR;
            case 'passed':
                return constants_1.TestStatus.SUCCESS;
            case 'disabled':
            case 'skipped':
            case 'pending':
            case 'todo':
                return constants_1.TestStatus.SKIPPED;
            case 'focused':
                return constants_1.TestStatus.QUEUED;
            default:
                console.error(`Unknown status: ${status}`);
                return constants_1.TestStatus.ERROR;
        }
    }
    get testPath() {
        return [
            ...this._assertionResult.ancestorTitles,
            this._assertionResult.title
        ];
    }
    get history() {
        return [];
    }
    get timestamp() {
        return this._testResult.perfStats.start;
    }
    get url() {
        return '';
    }
    get duration() {
        return this._assertionResult.duration ?? 0;
    }
}
exports.JestTestResultAdapter = JestTestResultAdapter;
//# sourceMappingURL=jest.js.map